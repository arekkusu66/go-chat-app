// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	types "gochat/types"
)

const areThereUnreadNotifications = `-- name: AreThereUnreadNotifications :one
SELECT EXISTS ( SELECT 1 FROM notifications WHERE user_id = $1 AND read = false )
`

func (q *Queries) AreThereUnreadNotifications(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, areThereUnreadNotifications, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAuthVerification = `-- name: CheckAuthVerification :one
SELECT EXISTS ( SELECT 1 FROM auth_verification WHERE user_id = $1 )
`

func (q *Queries) CheckAuthVerification(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAuthVerification, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkChatroomExistence = `-- name: CheckChatroomExistence :one
SELECT EXISTS ( SELECT 1 FROM chatrooms WHERE id = $1 )
`

func (q *Queries) CheckChatroomExistence(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkChatroomExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkIfAlreadyJoined = `-- name: CheckIfAlreadyJoined :one
SELECT EXISTS (
    SELECT 1
    FROM chatrooms c
    INNER JOIN user_joined_chatrooms ujc ON ujc.chatroom_id = $1 AND ujc.user_id = $2
)
`

type CheckIfAlreadyJoinedParams struct {
	ChatroomID int64     `json:"chatroom_id"`
	UserID     uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckIfAlreadyJoined(ctx context.Context, arg CheckIfAlreadyJoinedParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfAlreadyJoined, arg.ChatroomID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkIfMessageIsReply = `-- name: CheckIfMessageIsReply :one
SELECT EXISTS (
	SELECT 1
	FROM messages m
	LEFT JOIN messages r ON r.id = m.reply_id
	WHERE m.id = $1 AND r.user_id = $2
)
`

type CheckIfMessageIsReplyParams struct {
	ID     int64     `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckIfMessageIsReply(ctx context.Context, arg CheckIfMessageIsReplyParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfMessageIsReply, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkIfUserDMedUser = `-- name: CheckIfUserDMedUser :one
SELECT EXISTS (
    SELECT 1
    FROM dms
    WHERE (user1_id = $1 AND user2_id = $2) OR (user1_id = $2 AND user2_id = $1)
)
`

type CheckIfUserDMedUserParams struct {
	User1ID uuid.UUID `json:"user1_id"`
	User2ID uuid.UUID `json:"user2_id"`
}

func (q *Queries) CheckIfUserDMedUser(ctx context.Context, arg CheckIfUserDMedUserParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfUserDMedUser, arg.User1ID, arg.User2ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkIfUserIsInDM = `-- name: CheckIfUserIsInDM :one
SELECT EXISTS (
	SELECT 1
	FROM dms
	WHERE id = $1 AND (user1_id = $2 OR user2_id = $2)
)
`

type CheckIfUserIsInDMParams struct {
	ID      int64     `json:"id"`
	User1ID uuid.UUID `json:"user1_id"`
}

func (q *Queries) CheckIfUserIsInDM(ctx context.Context, arg CheckIfUserIsInDMParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfUserIsInDM, arg.ID, arg.User1ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMessageUserRelation = `-- name: CheckMessageUserRelation :one
SELECT EXISTS (
    SELECT 1
    FROM messages m
    INNER JOIN user_relations ur ON ur.relation_user_id = m.user_id
    WHERE ur.user_id = $1 AND m.id = $2 AND type = $3
)
`

type CheckMessageUserRelationParams struct {
	UserID uuid.UUID          `json:"user_id"`
	ID     int64              `json:"id"`
	Type   types.UserRelation `json:"type"`
}

func (q *Queries) CheckMessageUserRelation(ctx context.Context, arg CheckMessageUserRelationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkMessageUserRelation, arg.UserID, arg.ID, arg.Type)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMutualRelation = `-- name: CheckMutualRelation :one
SELECT EXISTS (
    SELECT 1
    FROM user_relations
    WHERE type = $1 AND ( 
        (user_id = $2 AND relation_user_id = $3) OR (user_id = $3 AND relation_user_id = $2)
    )
)
`

type CheckMutualRelationParams struct {
	Type           types.UserRelation `json:"type"`
	UserID         uuid.UUID          `json:"user_id"`
	RelationUserID uuid.UUID          `json:"relation_user_id"`
}

func (q *Queries) CheckMutualRelation(ctx context.Context, arg CheckMutualRelationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkMutualRelation, arg.Type, arg.UserID, arg.RelationUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkRelation = `-- name: CheckRelation :one
SELECT EXISTS ( SELECT 1 FROM user_relations WHERE user_id = $1 AND relation_user_id = $2 AND type = $3 )
`

type CheckRelationParams struct {
	UserID         uuid.UUID          `json:"user_id"`
	RelationUserID uuid.UUID          `json:"relation_user_id"`
	Type           types.UserRelation `json:"type"`
}

func (q *Queries) CheckRelation(ctx context.Context, arg CheckRelationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkRelation, arg.UserID, arg.RelationUserID, arg.Type)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserByProviderId = `-- name: CheckUserByProviderId :one
SELECT EXISTS ( SELECT 1 FROM users WHERE provider_id = $1 )
`

func (q *Queries) CheckUserByProviderId(ctx context.Context, providerID sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserByProviderId, providerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsernameAvailability = `-- name: CheckUsernameAvailability :one
SELECT EXISTS ( SELECT 1 FROM users WHERE username = $1 )
`

func (q *Queries) CheckUsernameAvailability(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUsernameAvailability, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAuthVerification = `-- name: CreateAuthVerification :exec
INSERT INTO auth_verification (user_id, type, token, expiry) VALUES ($1, $2, $3, $4)
`

type CreateAuthVerificationParams struct {
	UserID uuid.UUID          `json:"user_id"`
	Type   types.Verification `json:"type"`
	Token  string             `json:"token"`
	Expiry time.Time          `json:"expiry"`
}

func (q *Queries) CreateAuthVerification(ctx context.Context, arg CreateAuthVerificationParams) error {
	_, err := q.db.ExecContext(ctx, createAuthVerification,
		arg.UserID,
		arg.Type,
		arg.Token,
		arg.Expiry,
	)
	return err
}

const createChatroom = `-- name: CreateChatroom :one
INSERT INTO chatrooms (title, creator_id) VALUES ($1, $2) RETURNING id
`

type CreateChatroomParams struct {
	Title     string    `json:"title"`
	CreatorID uuid.UUID `json:"creator_id"`
}

func (q *Queries) CreateChatroom(ctx context.Context, arg CreateChatroomParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createChatroom, arg.Title, arg.CreatorID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDM = `-- name: CreateDM :exec
INSERT INTO dms (user1_id, user2_id) VALUES ($1, $2)
`

type CreateDMParams struct {
	User1ID uuid.UUID `json:"user1_id"`
	User2ID uuid.UUID `json:"user2_id"`
}

func (q *Queries) CreateDM(ctx context.Context, arg CreateDMParams) error {
	_, err := q.db.ExecContext(ctx, createDM, arg.User1ID, arg.User2ID)
	return err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    text,
    user_id,
    chatroom_id,
    dm_id,
    reply_id,
    reply_status
) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type CreateMessageParams struct {
	Text        string        `json:"text"`
	UserID      uuid.UUID     `json:"user_id"`
	ChatroomID  sql.NullInt64 `json:"chatroom_id"`
	DmID        sql.NullInt64 `json:"dm_id"`
	ReplyID     sql.NullInt64 `json:"reply_id"`
	ReplyStatus string        `json:"reply_status"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.Text,
		arg.UserID,
		arg.ChatroomID,
		arg.DmID,
		arg.ReplyID,
		arg.ReplyStatus,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNotification = `-- name: CreateNotification :exec
INSERT INTO notifications (
    message,
    link,
    type,
    user_id,
    notif_from
) VALUES ($1, $2, $3, $4, $5)
`

type CreateNotificationParams struct {
	Message   string    `json:"message"`
	Link      string    `json:"link"`
	Type      string    `json:"type"`
	UserID    uuid.UUID `json:"user_id"`
	NotifFrom string    `json:"notif_from"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) error {
	_, err := q.db.ExecContext(ctx, createNotification,
		arg.Message,
		arg.Link,
		arg.Type,
		arg.UserID,
		arg.NotifFrom,
	)
	return err
}

const createRelation = `-- name: CreateRelation :exec
INSERT INTO user_relations (user_id, relation_user_id, type) VALUES ($1, $2, $3)
`

type CreateRelationParams struct {
	UserID         uuid.UUID          `json:"user_id"`
	RelationUserID uuid.UUID          `json:"relation_user_id"`
	Type           types.UserRelation `json:"type"`
}

func (q *Queries) CreateRelation(ctx context.Context, arg CreateRelationParams) error {
	_, err := q.db.ExecContext(ctx, createRelation, arg.UserID, arg.RelationUserID, arg.Type)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (
    id,
    provider_id,
    username, 
    email, 
    verified,
    password
) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateUserParams struct {
	ID         uuid.UUID      `json:"id"`
	ProviderID sql.NullString `json:"provider_id"`
	Username   string         `json:"username"`
	Email      string         `json:"email"`
	Verified   bool           `json:"verified"`
	Password   sql.NullString `json:"-"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.ProviderID,
		arg.Username,
		arg.Email,
		arg.Verified,
		arg.Password,
	)
	return err
}

const deallocateAll = `-- name: DeallocateAll :exec
DEALLOCATE ALL
`

func (q *Queries) DeallocateAll(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deallocateAll)
	return err
}

const deleteAllNotifications = `-- name: DeleteAllNotifications :exec
DELETE FROM notifications WHERE id = $1
`

func (q *Queries) DeleteAllNotifications(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllNotifications, id)
	return err
}

const deleteAllNotificationsByType = `-- name: DeleteAllNotificationsByType :exec
DELETE FROM notifications WHERE user_id = $1 AND type = $2
`

type DeleteAllNotificationsByTypeParams struct {
	UserID uuid.UUID `json:"user_id"`
	Type   string    `json:"type"`
}

func (q *Queries) DeleteAllNotificationsByType(ctx context.Context, arg DeleteAllNotificationsByTypeParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllNotificationsByType, arg.UserID, arg.Type)
	return err
}

const deleteAuthVerification = `-- name: DeleteAuthVerification :exec
DELETE FROM auth_verification WHERE user_id = $1 AND type = $2
`

type DeleteAuthVerificationParams struct {
	UserID uuid.UUID          `json:"user_id"`
	Type   types.Verification `json:"type"`
}

func (q *Queries) DeleteAuthVerification(ctx context.Context, arg DeleteAuthVerificationParams) error {
	_, err := q.db.ExecContext(ctx, deleteAuthVerification, arg.UserID, arg.Type)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, id)
	return err
}

const deleteMutualRelation = `-- name: DeleteMutualRelation :exec
DELETE FROM user_relations
WHERE type = $1 AND (
    (user_id = $2 AND relation_user_id = $3) OR (user_id = $3 AND relation_user_id = $2)
)
`

type DeleteMutualRelationParams struct {
	Type           types.UserRelation `json:"type"`
	UserID         uuid.UUID          `json:"user_id"`
	RelationUserID uuid.UUID          `json:"relation_user_id"`
}

func (q *Queries) DeleteMutualRelation(ctx context.Context, arg DeleteMutualRelationParams) error {
	_, err := q.db.ExecContext(ctx, deleteMutualRelation, arg.Type, arg.UserID, arg.RelationUserID)
	return err
}

const deleteRelation = `-- name: DeleteRelation :exec
DELETE FROM user_relations WHERE user_id = $1 AND relation_user_id = $2 AND type = $3
`

type DeleteRelationParams struct {
	UserID         uuid.UUID          `json:"user_id"`
	RelationUserID uuid.UUID          `json:"relation_user_id"`
	Type           types.UserRelation `json:"type"`
}

func (q *Queries) DeleteRelation(ctx context.Context, arg DeleteRelationParams) error {
	_, err := q.db.ExecContext(ctx, deleteRelation, arg.UserID, arg.RelationUserID, arg.Type)
	return err
}

const getAllDMsWithStatus = `-- name: GetAllDMsWithStatus :many
SELECT id, user1_id, user2_id, status, creation_date FROM dms WHERE status = $1 AND (user1_id = $2 OR user2_id = $2)
`

type GetAllDMsWithStatusParams struct {
	Status  types.DM  `json:"status"`
	User1ID uuid.UUID `json:"user1_id"`
}

func (q *Queries) GetAllDMsWithStatus(ctx context.Context, arg GetAllDMsWithStatusParams) ([]Dm, error) {
	rows, err := q.db.QueryContext(ctx, getAllDMsWithStatus, arg.Status, arg.User1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dm
	for rows.Next() {
		var i Dm
		if err := rows.Scan(
			&i.ID,
			&i.User1ID,
			&i.User2ID,
			&i.Status,
			&i.CreationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJoinedUsers = `-- name: GetAllJoinedUsers :many
SELECT u.id, u.provider_id, u.username, u.email, u.password, u.join_date, u.verified, u.description
FROM chatrooms c
INNER JOIN user_joined_chatrooms ujc ON ujc.chat_id = c.id
INNER JOIN users u ON u.id = ujc.user_id
WHERE c.id = $1
`

func (q *Queries) GetAllJoinedUsers(ctx context.Context, id int64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllJoinedUsers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.JoinDate,
			&i.Verified,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMessages = `-- name: GetAllMessages :many
SELECT m.id, m.date, m.text, m.user_id, m.chatroom_id, m.dm_id, m.reply_id, m.reply_status
FROM messages m
INNER JOIN chatrooms c ON c.id = m.chatroom_id
WHERE c.id = $1
`

func (q *Queries) GetAllMessages(ctx context.Context, id int64) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getAllMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Text,
			&i.UserID,
			&i.ChatroomID,
			&i.DmID,
			&i.ReplyID,
			&i.ReplyStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNotifications = `-- name: GetAllNotifications :many
SELECT id, message, date, link, type, read, user_id, notif_from FROM notifications WHERE user_id = $1
`

func (q *Queries) GetAllNotifications(ctx context.Context, userID uuid.UUID) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getAllNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Message,
			&i.Date,
			&i.Link,
			&i.Type,
			&i.Read,
			&i.UserID,
			&i.NotifFrom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelations = `-- name: GetAllRelations :many
SELECT u.id, u.provider_id, u.username, u.email, u.password, u.join_date, u.verified, u.description
FROM users u
INNER JOIN user_relations ur ON ur.relation_user_id = u.id
WHERE ur.user_id = $1 AND type = $2
`

type GetAllRelationsParams struct {
	UserID uuid.UUID          `json:"user_id"`
	Type   types.UserRelation `json:"type"`
}

func (q *Queries) GetAllRelations(ctx context.Context, arg GetAllRelationsParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllRelations, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.JoinDate,
			&i.Verified,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthVerification = `-- name: GetAuthVerification :one
SELECT id, user_id, type, token, expiry FROM auth_verification WHERE user_id = $1 AND type = $2
`

type GetAuthVerificationParams struct {
	UserID uuid.UUID          `json:"user_id"`
	Type   types.Verification `json:"type"`
}

func (q *Queries) GetAuthVerification(ctx context.Context, arg GetAuthVerificationParams) (AuthVerification, error) {
	row := q.db.QueryRowContext(ctx, getAuthVerification, arg.UserID, arg.Type)
	var i AuthVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Token,
		&i.Expiry,
	)
	return i, err
}

const getAvailableChatrooms = `-- name: GetAvailableChatrooms :many
SELECT c.id, c.title, c.creator_id, c.created_at
FROM chatrooms c
WHERE NOT EXISTS (
	SELECT 1
	FROM user_joined_chatrooms ujc
	WHERE ujc.chatroom_id = c.id AND ujc.user_id = $1
) LIMIT $2 OFFSET $3
`

type GetAvailableChatroomsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetAvailableChatrooms(ctx context.Context, arg GetAvailableChatroomsParams) ([]Chatroom, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableChatrooms, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chatroom
	for rows.Next() {
		var i Chatroom
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatroom = `-- name: GetChatroom :one
SELECT id, title, creator_id, created_at FROM chatrooms WHERE id = $1
`

func (q *Queries) GetChatroom(ctx context.Context, id int64) (Chatroom, error) {
	row := q.db.QueryRowContext(ctx, getChatroom, id)
	var i Chatroom
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatorID,
		&i.CreatedAt,
	)
	return i, err
}

const getChatroomMessages = `-- name: GetChatroomMessages :many
SELECT m.id, m.date, m.text, m.user_id, m.chatroom_id, m.dm_id, m.reply_id, m.reply_status
FROM messages m
INNER JOIN chatrooms c ON c.id = m.chatroom_id
WHERE c.id = $1
LIMIT $2 OFFSET $3
`

type GetChatroomMessagesParams struct {
	ID     int64 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetChatroomMessages(ctx context.Context, arg GetChatroomMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getChatroomMessages, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Text,
			&i.UserID,
			&i.ChatroomID,
			&i.DmID,
			&i.ReplyID,
			&i.ReplyStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommonChatrooms = `-- name: GetCommonChatrooms :many
SELECT c.id, c.title, c.creator_id, c.created_at
FROM chatrooms c
INNER JOIN user_joined_chatrooms ujc1 ON ujc1.chatroom_id = c.id
INNER JOIN user_joined_chatrooms ujc2 ON ujc2.chatroom_id = c.id
WHERE ujc1.user_id = $1 AND ujc2.user_id = $2
`

type GetCommonChatroomsParams struct {
	UserID   uuid.UUID `json:"user_id"`
	UserID_2 uuid.UUID `json:"user_id_2"`
}

func (q *Queries) GetCommonChatrooms(ctx context.Context, arg GetCommonChatroomsParams) ([]Chatroom, error) {
	rows, err := q.db.QueryContext(ctx, getCommonChatrooms, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chatroom
	for rows.Next() {
		var i Chatroom
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCreatedChatrooms = `-- name: GetCreatedChatrooms :many
SELECT c.id, c.title, c.creator_id, c.created_at
FROM chatrooms c
INNER JOIN users u ON u.id = c.creator_id
WHERE u.id = $1
`

func (q *Queries) GetCreatedChatrooms(ctx context.Context, id uuid.UUID) ([]Chatroom, error) {
	rows, err := q.db.QueryContext(ctx, getCreatedChatrooms, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chatroom
	for rows.Next() {
		var i Chatroom
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCreatedChatroomsCount = `-- name: GetCreatedChatroomsCount :one
SELECT COUNT(*)
FROM chatrooms c
INNER JOIN users u ON u.id = c.creator_id
WHERE u.id = $1
`

func (q *Queries) GetCreatedChatroomsCount(ctx context.Context, id uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCreatedChatroomsCount, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCreator = `-- name: GetCreator :one
SELECT u.id, u.provider_id, u.username, u.email, u.password, u.join_date, u.verified, u.description
FROM users u
INNER JOIN chatrooms c ON c.creator_id = u.id
WHERE c.id = $1
`

func (q *Queries) GetCreator(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getCreator, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.JoinDate,
		&i.Verified,
		&i.Description,
	)
	return i, err
}

const getDMById = `-- name: GetDMById :one
SELECT id, user1_id, user2_id, status, creation_date FROM dms WHERE id = $1
`

func (q *Queries) GetDMById(ctx context.Context, id int64) (Dm, error) {
	row := q.db.QueryRowContext(ctx, getDMById, id)
	var i Dm
	err := row.Scan(
		&i.ID,
		&i.User1ID,
		&i.User2ID,
		&i.Status,
		&i.CreationDate,
	)
	return i, err
}

const getDMLastMessage = `-- name: GetDMLastMessage :one
SELECT m.id, m.date, m.text, m.user_id, m.chatroom_id, m.dm_id, m.reply_id, m.reply_status
FROM messages m 
INNER JOIN dms ON dms.id = m.dm_id
WHERE dms.id = $1 
ORDER BY m.id DESC
LIMIT 1
`

func (q *Queries) GetDMLastMessage(ctx context.Context, id int64) (Message, error) {
	row := q.db.QueryRowContext(ctx, getDMLastMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Text,
		&i.UserID,
		&i.ChatroomID,
		&i.DmID,
		&i.ReplyID,
		&i.ReplyStatus,
	)
	return i, err
}

const getDMWithBothUsers = `-- name: GetDMWithBothUsers :one
SELECT id, user1_id, user2_id, status, creation_date FROM dms WHERE (user1_id = $1 AND user2_id = $2) OR (user1_id = $2 AND user2_id = $1)
`

type GetDMWithBothUsersParams struct {
	User1ID uuid.UUID `json:"user1_id"`
	User2ID uuid.UUID `json:"user2_id"`
}

func (q *Queries) GetDMWithBothUsers(ctx context.Context, arg GetDMWithBothUsersParams) (Dm, error) {
	row := q.db.QueryRowContext(ctx, getDMWithBothUsers, arg.User1ID, arg.User2ID)
	var i Dm
	err := row.Scan(
		&i.ID,
		&i.User1ID,
		&i.User2ID,
		&i.Status,
		&i.CreationDate,
	)
	return i, err
}

const getDMWithUser = `-- name: GetDMWithUser :one
SELECT id, user1_id, user2_id, status, creation_date FROM dms WHERE id = $1 AND (user1_id = $2 OR user2_id = $2)
`

type GetDMWithUserParams struct {
	ID      int64     `json:"id"`
	User1ID uuid.UUID `json:"user1_id"`
}

func (q *Queries) GetDMWithUser(ctx context.Context, arg GetDMWithUserParams) (Dm, error) {
	row := q.db.QueryRowContext(ctx, getDMWithUser, arg.ID, arg.User1ID)
	var i Dm
	err := row.Scan(
		&i.ID,
		&i.User1ID,
		&i.User2ID,
		&i.Status,
		&i.CreationDate,
	)
	return i, err
}

const getDMmessages = `-- name: GetDMmessages :many
SELECT m.id, m.date, m.text, m.user_id, m.chatroom_id, m.dm_id, m.reply_id, m.reply_status
FROM messages m
WHERE m.dm_id = $1
`

func (q *Queries) GetDMmessages(ctx context.Context, dmID sql.NullInt64) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getDMmessages, dmID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Text,
			&i.UserID,
			&i.ChatroomID,
			&i.DmID,
			&i.ReplyID,
			&i.ReplyStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullMessageDatas = `-- name: GetFullMessageDatas :one
SELECT
    c.id AS chatroom_id, c.creator_id AS creator_id, 
    d.id AS dm_id,
    u.id AS user_id, u.username, 
    m.id, m.text, m.date, m.reply_id, m.reply_status,
    r.user_id AS reply_user_id, r.text AS reply_text
FROM messages m
INNER JOIN users u ON u.id = m.user_id
LEFT JOIN chatrooms c ON c.id = m.chatroom_id
LEFT JOIN dms d ON d.id = m.dm_id
LEFT JOIN messages r ON r.id = m.reply_id
WHERE m.id = $1
`

type GetFullMessageDatasRow struct {
	ChatroomID  sql.NullInt64  `json:"chatroom_id"`
	CreatorID   uuid.NullUUID  `json:"creator_id"`
	DmID        sql.NullInt64  `json:"dm_id"`
	UserID      uuid.UUID      `json:"user_id"`
	Username    string         `json:"username"`
	ID          int64          `json:"id"`
	Text        string         `json:"text"`
	Date        time.Time      `json:"date"`
	ReplyID     sql.NullInt64  `json:"reply_id"`
	ReplyStatus string         `json:"reply_status"`
	ReplyUserID uuid.NullUUID  `json:"reply_user_id"`
	ReplyText   sql.NullString `json:"reply_text"`
}

func (q *Queries) GetFullMessageDatas(ctx context.Context, id int64) (GetFullMessageDatasRow, error) {
	row := q.db.QueryRowContext(ctx, getFullMessageDatas, id)
	var i GetFullMessageDatasRow
	err := row.Scan(
		&i.ChatroomID,
		&i.CreatorID,
		&i.DmID,
		&i.UserID,
		&i.Username,
		&i.ID,
		&i.Text,
		&i.Date,
		&i.ReplyID,
		&i.ReplyStatus,
		&i.ReplyUserID,
		&i.ReplyText,
	)
	return i, err
}

const getJoinDate = `-- name: GetJoinDate :one
SELECT ujc.join_date
FROM user_joined_chatrooms ujc
WHERE ujc.chatroom_id = $1 AND ujc.user_id = $2
`

type GetJoinDateParams struct {
	ChatroomID int64     `json:"chatroom_id"`
	UserID     uuid.UUID `json:"user_id"`
}

func (q *Queries) GetJoinDate(ctx context.Context, arg GetJoinDateParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getJoinDate, arg.ChatroomID, arg.UserID)
	var join_date time.Time
	err := row.Scan(&join_date)
	return join_date, err
}

const getJoinedChatrooms = `-- name: GetJoinedChatrooms :many
SELECT c.id, c.title, c.creator_id, c.created_at
FROM chatrooms c
INNER JOIN user_joined_chatrooms ujc ON ujc.chatroom_id = c.id
WHERE ujc.user_id = $1 AND ujc.user_id <> c.creator_id
`

func (q *Queries) GetJoinedChatrooms(ctx context.Context, userID uuid.UUID) ([]Chatroom, error) {
	rows, err := q.db.QueryContext(ctx, getJoinedChatrooms, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chatroom
	for rows.Next() {
		var i Chatroom
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJoinedChatroomsCount = `-- name: GetJoinedChatroomsCount :one
SELECT COUNT(*)
FROM chatrooms c
INNER JOIN user_joined_chatrooms ujc ON ujc.chatroom_id = c.id
WHERE ujc.user_id = $1
`

func (q *Queries) GetJoinedChatroomsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getJoinedChatroomsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMessageById = `-- name: GetMessageById :one
SELECT id, date, text, user_id, chatroom_id, dm_id, reply_id, reply_status FROM messages WHERE id = $1
`

func (q *Queries) GetMessageById(ctx context.Context, id int64) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageById, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Text,
		&i.UserID,
		&i.ChatroomID,
		&i.DmID,
		&i.ReplyID,
		&i.ReplyStatus,
	)
	return i, err
}

const getNoficationById = `-- name: GetNoficationById :one
SELECT id, message, date, link, type, read, user_id, notif_from FROM notifications WHERE id = $1
`

func (q *Queries) GetNoficationById(ctx context.Context, id int64) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNoficationById, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.Date,
		&i.Link,
		&i.Type,
		&i.Read,
		&i.UserID,
		&i.NotifFrom,
	)
	return i, err
}

const getSettings = `-- name: GetSettings :one
SELECT user_id, accepts_friend_reqs, accepts_dm_reqs FROM settings WHERE user_id = $1
`

func (q *Queries) GetSettings(ctx context.Context, userID uuid.UUID) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings, userID)
	var i Setting
	err := row.Scan(&i.UserID, &i.AcceptsFriendReqs, &i.AcceptsDmReqs)
	return i, err
}

const getTheOtherDMuser = `-- name: GetTheOtherDMuser :one
SELECT u.id, u.provider_id, u.username, u.email, u.password, u.join_date, u.verified, u.description
FROM dms
JOIN users u ON u.id = CASE
    WHEN dms.user1_id = $1 THEN dms.user2_id
    ELSE dms.user1_id
END
WHERE dms.id = $2 AND (dms.user1_id = $1 OR dms.user2_id = $1)
`

type GetTheOtherDMuserParams struct {
	User1ID uuid.UUID `json:"user1_id"`
	ID      int64     `json:"id"`
}

func (q *Queries) GetTheOtherDMuser(ctx context.Context, arg GetTheOtherDMuserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getTheOtherDMuser, arg.User1ID, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.JoinDate,
		&i.Verified,
		&i.Description,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, provider_id, username, email, password, join_date, verified, description FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.JoinDate,
		&i.Verified,
		&i.Description,
	)
	return i, err
}

const getUserByMessage = `-- name: GetUserByMessage :one
SELECT u.id, u.provider_id, u.username, u.email, u.password, u.join_date, u.verified, u.description FROM users u INNER JOIN messages m ON m.user_id = u.id WHERE m.id = $1
`

func (q *Queries) GetUserByMessage(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByMessage, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.JoinDate,
		&i.Verified,
		&i.Description,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, provider_id, username, email, password, join_date, verified, description FROM users WHERE username = $1
`

func (q *Queries) GetUserByName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.JoinDate,
		&i.Verified,
		&i.Description,
	)
	return i, err
}

const getUserByProviderId = `-- name: GetUserByProviderId :one
SELECT id, provider_id, username, email, password, join_date, verified, description FROM users WHERE provider_id = $1
`

func (q *Queries) GetUserByProviderId(ctx context.Context, providerID sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByProviderId, providerID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.ProviderID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.JoinDate,
		&i.Verified,
		&i.Description,
	)
	return i, err
}

const getUserChatroomDatas = `-- name: GetUserChatroomDatas :one
SELECT u.description, ujc.join_date
FROM users u
INNER JOIN user_joined_chatrooms ujc ON ujc.user_id = u.id
WHERE u.id = $1 AND ujc.chatroom_id = $2
`

type GetUserChatroomDatasParams struct {
	ID         uuid.UUID `json:"id"`
	ChatroomID int64     `json:"chatroom_id"`
}

type GetUserChatroomDatasRow struct {
	Description sql.NullString `json:"description"`
	JoinDate    time.Time      `json:"join_date"`
}

func (q *Queries) GetUserChatroomDatas(ctx context.Context, arg GetUserChatroomDatasParams) (GetUserChatroomDatasRow, error) {
	row := q.db.QueryRowContext(ctx, getUserChatroomDatas, arg.ID, arg.ChatroomID)
	var i GetUserChatroomDatasRow
	err := row.Scan(&i.Description, &i.JoinDate)
	return i, err
}

const getUsersCount = `-- name: GetUsersCount :one
SELECT COUNT(*)
FROM chatrooms c
INNER JOIN user_joined_chatrooms ujc ON ujc.chatroom_id = c.id
WHERE c.id = $1
`

func (q *Queries) GetUsersCount(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUsersCount, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertDefaultSettings = `-- name: InsertDefaultSettings :exec
INSERT INTO settings (user_id) VALUES ($1)
`

func (q *Queries) InsertDefaultSettings(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, insertDefaultSettings, userID)
	return err
}

const joinChatroom = `-- name: JoinChatroom :exec
INSERT INTO user_joined_chatrooms (user_id, chatroom_id) VALUES ($1, $2)
`

type JoinChatroomParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ChatroomID int64     `json:"chatroom_id"`
}

func (q *Queries) JoinChatroom(ctx context.Context, arg JoinChatroomParams) error {
	_, err := q.db.ExecContext(ctx, joinChatroom, arg.UserID, arg.ChatroomID)
	return err
}

const leaveChatroom = `-- name: LeaveChatroom :exec
DELETE FROM user_joined_chatrooms WHERE user_id = $1 AND chatroom_id = $2
`

type LeaveChatroomParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ChatroomID int64     `json:"chatroom_id"`
}

func (q *Queries) LeaveChatroom(ctx context.Context, arg LeaveChatroomParams) error {
	_, err := q.db.ExecContext(ctx, leaveChatroom, arg.UserID, arg.ChatroomID)
	return err
}

const readNotification = `-- name: ReadNotification :exec
UPDATE notifications SET read = true WHERE id = $1
`

func (q *Queries) ReadNotification(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, readNotification, id)
	return err
}

const unreadNotificationsCount = `-- name: UnreadNotificationsCount :one
SELECT COUNT(*) FROM notifications WHERE user_id = $1 AND read = false
`

func (q *Queries) UnreadNotificationsCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, unreadNotificationsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateDM = `-- name: UpdateDM :exec
UPDATE dms SET status = $1 WHERE id = $2
`

type UpdateDMParams struct {
	Status types.DM `json:"status"`
	ID     int64    `json:"id"`
}

func (q *Queries) UpdateDM(ctx context.Context, arg UpdateDMParams) error {
	_, err := q.db.ExecContext(ctx, updateDM, arg.Status, arg.ID)
	return err
}

const updateReply = `-- name: UpdateReply :exec
UPDATE messages SET reply_id = NULL, reply_status = $1 WHERE reply_id = $2
`

type UpdateReplyParams struct {
	ReplyStatus string        `json:"reply_status"`
	ReplyID     sql.NullInt64 `json:"reply_id"`
}

func (q *Queries) UpdateReply(ctx context.Context, arg UpdateReplyParams) error {
	_, err := q.db.ExecContext(ctx, updateReply, arg.ReplyStatus, arg.ReplyID)
	return err
}

const updateSettings = `-- name: UpdateSettings :exec
UPDATE settings
SET
    accepts_friend_reqs = CASE
        WHEN $1::TEXT = 'yes' THEN true
        WHEN $1::TEXT = 'no' THEN false END,
    accepts_dm_reqs = CASE
        WHEN $2::TEXT = 'yes' THEN true
        WHEN $2::TEXT = 'no' THEN false END
WHERE user_id = $3
`

type UpdateSettingsParams struct {
	AcceptsFriendReqs string    `json:"accepts_friend_reqs"`
	AcceptsDmReqs     string    `json:"accepts_dm_reqs"`
	UserID            uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateSettings(ctx context.Context, arg UpdateSettingsParams) error {
	_, err := q.db.ExecContext(ctx, updateSettings, arg.AcceptsFriendReqs, arg.AcceptsDmReqs, arg.UserID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users 
SET username = COALESCE(NULLIF($2::TEXT, ''), username),
    password = COALESCE(NULLIF($3::TEXT, ''), password),
    verified = CASE 
                WHEN $4::BOOL = TRUE AND verified = FALSE THEN TRUE 
                WHEN $4::BOOL = FALSE AND verified = TRUE THEN TRUE
                WHEN $4::BOOL = TRUE AND verified = TRUE THEN TRUE 
                ELSE FALSE END,
    description = COALESCE(NULLIF($5::TEXT, ''), description)
WHERE id = $1
`

type UpdateUserParams struct {
	ID          uuid.UUID `json:"id"`
	Username    string    `json:"username"`
	Password    string    `json:"password"`
	Verified    bool      `json:"verified"`
	Description string    `json:"description"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Password,
		arg.Verified,
		arg.Description,
	)
	return err
}
